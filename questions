i've managed to make sprites dissapear, but not to stop the collisions after the sprite stops showing.

```py
#here is the sprite class
class newSprite(pygame.sprite.Sprite):
    def __init__(self, filename, frames=1):
        pygame.sprite.Sprite.__init__(self)
        self.images = []
        img = loadImage(filename)
        self.originalWidth = img.get_width() // frames
        self.originalHeight = img.get_height()
        frameSurf = pygame.Surface((self.originalWidth, self.originalHeight), pygame.SRCALPHA, 32)
        x = 0
        for frameNo in range(frames):
            frameSurf = pygame.Surface((self.originalWidth, self.originalHeight), pygame.SRCALPHA, 32)
            frameSurf.blit(img, (x, 0))
            self.images.append(frameSurf.copy())
            x -= self.originalWidth
        self.image = pygame.Surface.copy(self.images[0])

        self.currentImage = 0
        self.rect = self.image.get_rect()
        self.rect.topleft = (0, 0)
        self.mask = pygame.mask.from_surface(self.image)
        self.angle = 0
        self.scale = 1

    def addImage(self, filename):
        self.images.append(loadImage(filename))

    def move(self, xpos, ypos, centre=False):
        if centre:
            self.rect.center = [xpos, ypos]
        else:
            self.rect.topleft = [xpos, ypos]

    def changeImage(self, index):
        self.currentImage = index
        if self.angle == 0 and self.scale == 1:
            self.image = self.images[index]
        else:
            self.image = pygame.transform.rotozoom(self.images[self.currentImage], -self.angle, self.scale)
        oldcenter = self.rect.center
        self.rect = self.image.get_rect()
        originalRect = self.images[self.currentImage].get_rect()
        self.originalWidth = originalRect.width
        self.originalHeight = originalRect.height
        self.rect.center = oldcenter
        self.mask = pygame.mask.from_surface(self.image)
        if screenRefresh:
            updateDisplay()
# here is the where the collision is done, its in the while loop
    for killer in enemies:
        if touching(hero,killer):
            health = health - 1
            changeLabel(display_health, str(health), hpcolor)
            updateDisplay()
            print('you have been hit by enemy -1health')
        if touching(hero_weapon,killer):
            print('you have hit by enemy- it dies')
            changeSpriteImage(killer, 1)
            killer.yspeed = 0
            #killer == deadkiller
            killSprite(killer)

            updateDisplay()
#here is the killSprite function
def killSprite(sprite):
    sprite.kill()
    if screenRefresh:
        updateDisplay()
#the question is, what should i add to killSprite function, or make another, to stop the collisions happening?

```



i pytanie drugie
i've also managed to make the sprite move when the hero moves. but in future i'd like to make whole swarm of objects(enemies, items, background elements) to move, making the illusion of the world, spawning them in ranges.

```py
#here is the sprite 
fallen_star = makeSprite('data/img/Golden Saint.png')
addSpriteImage(fallen_star, 'data/img/death coin.png')
fallen_star.x = random.randint(0,350) # w jakim miejscu sie spawnuje x
fallen_star.y = random.randint(400,450)  # w jakim miejscu sie spawnuje y
fallen_star.xspeed = random.randint(0,0)
fallen_star.yspeed = random.randint(0,0)
moveSprite(fallen_star, fallen_star.x, fallen_star.y, True)
showSprite(fallen_star)
# and the bordes in which it moves(it doesnt move by itself right now, only when the hero moves)
#its in the while loop
fallen_star.x += fallen_star.xspeed
    if fallen_star.x > 640:
        fallen_star.x = 0
    elif fallen_star.x < 0:
        fallen_star.x = 640
    fallen_star.y += fallen_star.yspeed
    if fallen_star.y > 800:
        fallen_star.y = 0
    elif fallen_star.y < 0:
        fallen_star.y = 800
    moveSprite(fallen_star, fallen_star.x, fallen_star.y)
#here is example of moving the hero, the sprite moves when the hero moves
    if keyPressed("up"):
        changeSpriteImage(hero, 0)
        transformSprite(hero, -180, 1)
        scrollBackground(0,5)
        fallen_star.y = fallen_star.y + 5
        moveSprite(fallen_star, fallen_star.x, fallen_star.y)

#this works. but how do i make this happen in context of enemies i spawn in for loop?
enemies = []
#sprites spawning
for x in range(10):
    killer = makeSprite('data/img/crab angel.png')
    addSpriteImage(killer, 'data/img/death coin.png')
    deadkiller = makeSprite('data/img/crawler.png')
    killer.x = random.randint(1,10) # w jakim miejscu sie spawnuje x
    killer.y = random.randint(1,10)  # w jakim miejscu sie spawnuje y
    killer.xspeed = random.randint(2,3)
    killer.yspeed = random.randint(1,2)
    moveSprite(killer, killer.x, killer.y, True)
    showSprite(killer)
    enemies.append(killer)
#the enemies list has the same borders, its just in a forloop
    for killer in enemies:
        killer.x += killer.xspeed
        if killer.x > 640:
           killer.x = 0
        elif killer.x < 0:
            killer.x = 640
        killer.y += killer.yspeed
        if killer.y > 800:
            killer.y = 0
        elif killer.y < 0:
            killer.y = 800
        moveSprite(killer, killer.x, killer.y, True)
#can i append the single sprite to a list, and make the list of sprites move when the hero moves, also, if ill make lots of lists of items, like health boosts(which will interact with the hero, giving him hp), trees and stuff, can i append the lists to a list and move them all together to write less code?


```
